# React18 并发“模式”（Concurrent "Mode"）的前世今生

> 发布于 2021.11.10，最后更新于 2021.11.10。
>
> 原 Discussion：https://github.com/reactwg/react-18/discussions/64

笔者的话：这篇讨论讲述了并发“模式”（Concurrent "Mode"）的由来、发展和现况。可以看出 React 团队在版本升级这方面十分谨慎。每当有一个跨时代的新思想、新 API 出现在框架，React 团队在“折磨”别人的同时也在“折磨”着自己，他们不断探讨升级策略，同时接收社区反馈。作为 React 用户，我们应该乐观地看待这些新思想、新模式，React 团队的体贴与负责，让我觉得升级也不是件难以推动的事 :)

## 概述

React18 将加入 `startTransition`、`useDeferredValue`、并发 `Suspense` 语法、`SuspenseList` 等等这些新特性。为了推动这些新特性，React 引入了一些思想，比如协调式多任务处理（Cooperative Multitasking）、基于优先级渲染（Priority-based Rendering）、调度（Scheduling）以及中断（Interruptions）。

得益于能智能地决定何时进行子树渲染（或中止渲染），这些特性解锁了新一代性能和用户体验。这些新特性的开销，仅仅是从思想上乐观地拥抱它们并把代码写出来。

为了帮助用户搞清楚他们的代码是否兼容，React 加入了很多开发环境下的警告和行为，我们叫它严格模式 `StrictMode`。在严格模式下，会警告用户不安全的行为，并把不当地使用并发特性的 bug 暴露出来。我们在 React16.3 引入了 `StrictMode`，好让社区为这些新功能提前做好准备。

这个帖子是面向那些紧密跟进实验性分支、想知道 Concurrent "Mode" 究竟发生了什么的人们。我们会提供如何推动这些新特性的概览，并解释说明为什么说其实没有并发模式这一模式，而只是一些并发功能特性罢了。

## 什么是并发“模式”

从一开始想到要在 React 中加入这些新特性是因为这可能是所有应用的默认行为。这意味着，升级版本后，整个应用将启用并发“模式”。这会令应用中的一切都是并发渲染的。为确保这种方式是安全的，我们默认开启了 `StrictMode`。这个策略的思考是，只要用户升级版本就能享有并发渲染的性能收益。

然而，在收到了社区中对这个改变的影响反馈后，我们考虑应逐步地去完成版本升级。显然，这个策略的落地需要有一个逐渐的过程，React17 就是这个过程的第一步。

在 React17 中，可以让一个应用使用不同 React 版本，用户可以增量地将整个根组件转为 React18，并在 React17 版本保留旧的根组件，像以往版本那样渲染相同的结果。但这种策略有一个缺陷，就是根组件可能很庞大，蔓延着成百上千个文件。因此在根组件中，用户需要一个能逐渐适应并迁移到 React18 的方案。

## 逐步升级尝试的第一步：Blocking Mode

逐渐去[适应并发模式](https://reactjs.org/docs/concurrent-mode-adoption.html)的策略中，包含了 3 种模式：

* **Legacy 模式**：就是 React17 中使用的现有模式
  * 默认禁止 `StrictMode`；
  * 默认同步渲染；
  * 旧的 Suspense 语法；
* **Blocking 模式**：在 Legacy 和 Concurrent 之间的混合模式
  * 默认启用 `StrictMode`；
  * 默认同步渲染；
  * 一些新特性支持；
* **Concurrent 模式**：在 React18 中使用的新模式
  * 默认启用 `StrictMode`；
  * 默认并发渲染；
  * 所有新特性支持；

这种策略下，用户可以先将现有 Legacy 模式根组件，转成 Blocking 模式，最后再转成 Concurrent 模式。

Blocking 模式会启用所有的 `StrictMode` 警告和开发环境行为，而对于更新渲染、Suspense 语法则没有任何改变。用户可以发现整个根组件的问题，确保代码能继续在生产环境运行的同时去修复它们。最终等所有问题都修复后，自然而然可以无缝地切换到 Concurrent 模式。

## Blocking 模式的问题

我们发现这种策略伴随着一些问题：

1. 在 Blocking 模式下启用所有 `StrictMode` 警告，而没有一个好策略来增量修复它们，这会让用户觉得不堪重负。尽管应用仍会工作，但没有一个好的方式来迅速应对开发环境中出现的各种警告并修复它们。这个策略本期望能增量地去迁移根组件，但实践结果仍是要么完全迁移，要么一点也迁移不动；
2. 我们认识到只有通过使用并发特性，应用才能享有大多数并发渲染的好处。让并发渲染成为默认行为将令应用持续受益（也许未来会考虑这么做），但这大多是由 `startTransition` 或 Suspense API 完成的。也就是说我们不需要改变默认语法，取而代之的是，用户可以可选地将并发特性加入到并发渲染中，这样就能在增量地去测试并升级到新语法的同时享有并发特性的好处；
3. 对于上面这些变更，Blocking 模式和 Concurrent 模式的唯一区别就是前者默认启用了所有警告。但如果默认没有并发渲染场景，我们就不必默认开启 `StrictMode`。另外，在进行了更多调查后发现，我们对并发警告过于谨慎了，大多数代码都能正常工作（尤其是进行了上述变更）的情况下，我们过于着急地通过警告表达了担忧。

基于以上这些原因，我们认识到，我们在整个应用层面为每个理论上的错误提示了警告，但如果没用并发特性，这些警告的问题并不会导致错误，我们其实没必要去阻止迁移。以上种种，让我们重新思考迁移策略。

## 并发特性

在 [React18 发布计划](https://reactjs.org/blog/2021/06/08/the-plan-for-react-18.html) 中，我们分享了不需要为并发特性做任何变更就能升级到 React18 的新策略，循序渐进地在可选的并发渲染中使用并发特性。这新策略下，因为我们在 React18 中包含了 React17 下的根组件，所以无需什么 Blocking 模式，也没必要在应用中引入这两个不同的 React 版本。

这种方式本质上来看属于 Blocking 模式与 Concurrent 模式的混合。默认，React 会像之前的 Legacy 或 Blocking 模式那样同步地渲染更新。这意味着当你刚升级完，在使用新 API 前，一切渲染照旧。唯一的区别只是有一些与并发特性无关的开箱即用的改善（如自动批处理）。

由于应用默认不是并发渲染的，我们也无需默认启用 `StrictMode`。取而代之的是，用户可以自行将 `StrictMode` 添加到他们应用中实际使用了并发特性的那一小部分中。

基于这点，一旦完成更新，本质上你已经在用并发模式了。事实上，`createRoot` API 一直 [维护着一个根节点 Tag](https://github.com/facebook/react/blob/28625c6f45423e6edc5ca0e2932281769c0d431e/packages/react-reconciler/src/ReactFiber.new.js#L427-L428) 来支持并发模式。如今不同的是，我们改变了“并发模式”在 React 中意味着什么——如果没用并发特性，那就没什么并发渲染。

因此，这就是为什么我们说“没有什么并发模式，而只是有一些并发特性”罢了。
