# React 18 新特性：startTransition

> 发布于 2021.11.09，最后更新于 2021.11.09。
>
> 原 Discussion：https://github.com/reactwg/react-18/discussions/41

## 概述

在 React18 中我们引进了一个新 API，让应用即便在大屏更新场景下仍能保持响应。这个新 API 通过将指定的更新标记为“transition”来大幅提高用户交互体验。React 会让你提供 state 转变时的视觉反馈并在转变过程中保持浏览器可响应。

* [真实案例：为慢渲染加入 startTransition](https://github.com/reactwg/react-18/discussions/65)

## 解决什么问题？

构建流畅的、可响应的 APP 并不是件容易的事。有时一些很小的行为，比如点按钮或是往输入框中输内容，却会导致屏幕上有很多事发生。这些事在执行时可能会导致页面卡死。

设想，在输入框输入值，然后过滤一个数据列表。你需要将字段值存在 state 中，以便用它来过滤数据并且控制输入框的值。代码就像这样：

```js
// 更新 input 的值并搜索结果
setSearchQuery(input);
```

这样的话，每当输入一个新字符，就会更新输入框的值并且用这个新值去搜索列表、显示结果。

对于大屏更新场景，这会导致页面更新的延迟，从而任何要渲染的、输入的以及其他交互形式都会觉得慢，觉得没响应。即便数据列表不是很长，但每一个列表项可能很复杂，随着一次次的键盘敲击，它们不停地变化，没有一个清晰的方式来优化渲染。

抽象来看，问题的原因是发生了两个不同的更新：

* 改变输入框的值，有时还会涉及一些潜在的 UI 更新。这是紧急的更新；
* 显示搜索结果。这是非紧急的更新；

```js
// 紧急：显示我们输入了什么
setInputValue(input);

// 非紧急：显示搜索结果
setSearchQuery(input);
```

用户期望紧急的更新立刻执行，因为原生浏览器处理这些交互就很快。但非紧急的更新可以有一些延迟，由于有很多事要处理，用户并不奢望它们能立刻完成。（事实上，Developer 们也经常会用类似防抖这样的技术手段来人为延迟）

React18 前，所有更新都是紧急渲染的。意味着上面两种更新都是在一次更新中同时进行的，这会一直阻塞用户看到交互反馈，直到一切都渲染完毕。我们欠缺的是一种机制，可以告知 React 哪些更新紧急，哪些又不紧急。

## startTransition 是如何帮助的？

新的 `startTransition` API 通过赋予你将更新标记为 “transitions” 的能力来解决这个问题：

```js
import { startTransition } from 'react';

// 紧急：显示我们输入了什么
setInputValue(input);

// 将其中的 state 更新标记为 transitions
startTransition(() => {
  // Transition: 显示搜索结果
  setSearchQuery(input);
});
```

被 `startTransition` 包裹的更新会视为非紧急（non-urgent）更新，如果有更紧急的更新进来，比如点击、敲键盘，非紧急更新将会被打断。如果 transition 过程被用户行为打断了（比如在一行中连续输入多个字符），React 会扔掉未完成的 state 渲染任务，并仅渲染最后过来的更新。

即使一些交互会导致大量的 UI 变化，Transitions 也会让这些交互潇洒地进行，同时也避免了在无关的渲染上浪费时间。

## Transition 是什么？

我们将 state 更新分为两类：

* **紧急更新**（Urgent updates）：响应用户直接的交互，比如打字输入、点击、按下等等；
* **过渡更新**（Transition updates）：将 UI 界面从一个视图过渡到另一个视图。

对于紧急更新，像打字输入、点击、按下等，这些属于物理行为，需要立即给到响应以匹配用户直觉，不然用户会觉得出错了。对于过渡更新确不是这样，因为用户并不期望立刻在屏幕上看到更新结果。

举个例子，通过下拉选择来过滤数据。当你选择选项时，期望点击后立即得到反馈，而过滤的结果可以通过过渡更新来完成。这些小延迟往往是察觉不到的，即便察觉到那也是意料之中。而且在最终完成过滤结果的渲染前，如果再次进行了下拉选择，那么只关心最后那次选择的过滤结果就好了。

在一个典型的 React 应用中，概念上来说绝大多数更新都是过渡更新。但考虑到向前兼容，过渡更新是可选的。React18 默认会将更新当做紧急更新，通过将更新包裹进 `startTransition` 来让它成为非紧急更新。

## 这和 setTimeout 有什么区别？

上面这个问题的一个常见解决方案是将次要更新放在 `setTimeout` 函数中：

```js
// 显示我们输入了什么
setInputValue(input);

// 显示搜索结果
setTimeout(() => {
  setSearchQuery(input);
}, 0);
```

这确实会延迟次要更新，直到主要更新渲染完。防抖和节流是这种方案的变种。

一个重要的区别是，`startTransition` 并不像 `setTimeout` 那样预定好要延迟执行。它是立即执行的。传递给 `startTransition` 的函数是同步执行的，只是它其中的任何更新会被标记为 “Transition”。React 将在后续更新中使用到这些信息，从而决定如何去渲染这次更新。这意味着开始渲染更新的时间要早于包裹进 `setTimeout` 这种方式。在比较快的设备上，这两次主次更新间的延迟非常非常小。而在比较慢的设备上，延迟会更久一些，但 UI 确是保持可响应的。

另一个很重要的区别是，在 `setTimeout` 中包裹的大屏更新仍旧会让页面卡死，这只是在延时后发生罢了。延时完毕，如果用户依然持续地输入或是进行其他一些交互，他们还是会因页面响应而被卡到。然而，通过 `startTransition` 标记的 state 更新是可中断的，所以它们不会让页面卡死。这让浏览器在处理不同组件的渲染过程中有一个更小的间隙来处理事件。输入一旦改变，React 将不会执着于保持那些用户不再感兴趣的渲染。

总之，由于 `setTimeout` 只是简单地延迟去更新，为了显示一个 Loading 提示还要写些脆弱的异步代码。而结合 Transitions，React 会为你跟踪那些改变中的 state，然后基于过渡过程中当前的 state 完成更新，当然也提供等待时显示 Loading 的能力。

## 过渡过程中我们要做些什么？

通知用户有一些工作正在后台进行是一种最佳实践。为此，我们提供了用 `isPending` 标识过渡的 Hook：

```js
import { useTransition } from 'react';

const [isPending, startTransition] = useTransition();
```

当过渡正在进行时，`isPending` 的值为 `true`，这时我们可以为等待的用户显示一个 Spinner：

```js
{isPending && <Spinner />}
```

在 Transition 中包裹的 state 更新不一定非要产生于同一个组件。比如，在搜索框组件中的 Spinner 也可以用来反映搜索结果的重新渲染。

## 何不去写运行更快的代码？

写运行更快的代码，并避免不必要的重新渲染，这一直是很好的优化性能方式。Transitions 与这种方式是互补的。这使得即便在大规模的视图改变下仍能保持 UI 可响应。使用以往的现有策略很难去进一步优化。即便没有非必要的重新渲染，相比于将所有更新都视为紧急更新，Transition 方式仍会提供一个更好的用户体验。

## 在哪里用它呢？

可以使用 `startTransition` 来包裹任何想转移到后台运行的更新。这类更新可以分为两种典型的情况：

* 渲染慢：由于 React 要执行大量工作来完成让 UI 显示最终结果的过渡，导致这些更新需要一定时间。[这有个在大量重新渲染场景下，使用 `startTransition` 让应用保持可响应的真实示例](https://github.com/reactwg/react-18/discussions/65)；
* 网速慢：由于 React 要等待来自网络请求的数据，导致这些这些更新需要一定时间。这类场景与 Suspense 密切相关。
